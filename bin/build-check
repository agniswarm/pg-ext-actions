#!/usr/bin/env bash
# test/bin/build-check
# Robust cross-platform build / install / installcheck wrapper for PostgreSQL extensions.
#
# Usage:
#   test/bin/build-check [OPERATING_SYSTEM] [EXTRA_MAKE_VARS]
# Example:
#   test/bin/build-check "linux" "PGUSER=postgres"
#   test/bin/build-check "macos"
#
# Behavior:
# - Uses specified OS or auto-detects (linux|macos|windows).
# - Runs: make -> make install -> make installcheck (with EXTRA_MAKE_VARS).
# - On failure prints regression.diffs (if present) and exits non-zero.
# - On success exits 0 and prints success messages only.
#
set -euo pipefail
IFS=$'\n\t'

log()  { printf '\033[1;34m[build-check]\033[0m %s\n' "$*"; }
ok()   { printf '\033[1;32m[build-check]\033[0m %s\n' "$*"; }
err()  { printf '\033[1;31m[build-check]\033[0m %s\n' "$*"; }

detect_os() {
    case "$(uname -s)" in
        Linux*)  echo "linux" ;;
        Darwin*) echo "macos" ;;
        CYGWIN*|MINGW*|MSYS*) echo "windows" ;;
        *)       echo "unknown" ;;
    esac
}

# Find PostgreSQL utilities (pg_config, psql, pg_isready, etc.)
find_pg_utility() {
    local utility="$1"
    local pg_config_path="$2"
    
    if [ -z "$pg_config_path" ]; then
        # If no pg_config path provided, try common locations dynamically
        for base_dir in "/opt/homebrew" "/usr/local"; do
            if [ -d "$base_dir" ]; then
                # Check bin directory first
                if [ -x "$base_dir/bin/$utility" ]; then
                    echo "$base_dir/bin/$utility"
                    return 0
                fi
                # Then check version-specific directories
                if [ -d "$base_dir/opt" ]; then
                    for version_dir in $(ls -1 "$base_dir/opt" 2>/dev/null | grep -E '^postgresql@[0-9]+(\.[0-9]+)?$' | sort -V -r); do
                        pg_path="$base_dir/opt/$version_dir/bin/$utility"
                        if [ -x "$pg_path" ]; then
                            echo "$pg_path"
                            return 0
                        fi
                    done
                fi
            fi
        done
        
        # Try which command as fallback
        if command -v "$utility" >/dev/null 2>&1; then
            command -v "$utility"
            return 0
        fi
    else
        # Use pg_config location to find other utilities
        local pg_bin_dir="$(dirname "$pg_config_path")"
        local pg_util_path="$pg_bin_dir/$utility"
        
        if [ -x "$pg_util_path" ]; then
            echo "$pg_util_path"
            return 0
        fi
    fi
    
    return 1
}

# Check if PostgreSQL is ready to accept connections
check_pg_ready() {
    local max_attempts=30
    local attempt=1
    
    log "Checking if PostgreSQL is ready..."
    
    while [ $attempt -le $max_attempts ]; do
        if [ -n "$PG_ISREADY" ] && [ -x "$PG_ISREADY" ]; then
            if "$PG_ISREADY" -q; then
                ok "PostgreSQL is ready (attempt $attempt/$max_attempts)"
                return 0
            fi
        elif command -v pg_isready >/dev/null 2>&1; then
            if pg_isready -q; then
                ok "PostgreSQL is ready (attempt $attempt/$max_attempts)"
                return 0
            fi
        else
            # Fallback: try to connect with psql
            if [ -n "$PG_PSQL" ] && [ -x "$PG_PSQL" ]; then
                if "$PG_PSQL" -c "SELECT 1;" >/dev/null 2>&1; then
                    ok "PostgreSQL is ready (attempt $attempt/$max_attempts)"
                    return 0
                fi
            elif command -v psql >/dev/null 2>&1; then
                if psql -c "SELECT 1;" >/dev/null 2>&1; then
                    ok "PostgreSQL is ready (attempt $attempt/$max_attempts)"
                    return 0
                fi
            fi
        fi
        
        log "PostgreSQL not ready yet, waiting... (attempt $attempt/$max_attempts)"
        sleep 2
        attempt=$((attempt + 1))
    done
    
    err "PostgreSQL is not ready after $max_attempts attempts"
    return 1
}

show_regression_diffs() {
    if [ -f regression.diffs ]; then
        echo
        echo "===================== regression.diffs ====================="
        sed -n '1,400p' regression.diffs || true
        echo "==========================================================="
    else
        log "No regression.diffs file found"
    fi
}

# run a command (array) and return its exit code (prints helpful logs)
run_cmd() {
    local -a cmd=( "$@" )
    log "Running: ${cmd[*]}"
    if "${cmd[@]}"; then
        ok "Command succeeded: ${cmd[*]}"
        return 0
    else
        local rc=$?
        err "Command failed (exit ${rc}): ${cmd[*]}"
        return $rc
    fi
}

# run make in a cross-platform way
# $1 = target (empty string for default build)
# $2 = extra vars (single string, e.g. "PGUSER=postgres")
run_make() {
    local target="${1:-}"    # may be empty
    local extra="${2:-}"     # may be empty
    local cmd_arr

    case "$OS" in
        windows)
            # Set up PostgreSQL environment for Windows (will be updated after finding pg_config)
            export PATH="$PATH"
            
            # Find PostgreSQL installation dynamically
            PG_CONFIG_FOUND=""
            
            # First, try to find any PostgreSQL installation in common locations
            for pg_dir in "/c/Program Files/PostgreSQL" "/c/Program Files (x86)/PostgreSQL"; do
                if [ -d "$pg_dir" ]; then
                    log "Searching for PostgreSQL in: $pg_dir"
                    # Find the highest version number (most recent installation)
                    for version_dir in $(ls -1 "$pg_dir" 2>/dev/null | grep -E '^[0-9]+(\.[0-9]+)?$' | sort -V -r); do
                        pg_path="$pg_dir/$version_dir/bin/pg_config"
                        if [ -x "$pg_path" ]; then
                            export PG_CONFIG="$pg_path"
                            PG_CONFIG_FOUND="true"
                            log "Found pg_config at: $pg_path (version: $version_dir)"
                            break 2
                        fi
                    done
                fi
            done
            
            # If not found in common locations, try which command
            if [ -z "$PG_CONFIG_FOUND" ]; then
                if command -v pg_config >/dev/null 2>&1; then
                    export PG_CONFIG="$(command -v pg_config)"
                    PG_CONFIG_FOUND="true"
                    log "Found pg_config via which: $PG_CONFIG"
                fi
            fi
            
            # If still not found, error out
            if [ -z "$PG_CONFIG_FOUND" ]; then
                err "pg_config not found. PostgreSQL development packages may not be installed."
                err "Please ensure PostgreSQL is installed via Chocolatey: choco install postgresql<version>"
                exit 1
            fi
            
            # Set additional PostgreSQL environment variables
            PG_CONFIG_DIR="$(dirname "$PG_CONFIG")"
            PG_ROOT="$(dirname "$PG_CONFIG_DIR")"
            
            # Convert Unix-style paths to Windows-style for Windows make tools
            PG_CONFIG_DIR_WIN=$(echo "$PG_CONFIG_DIR" | sed 's|^/c/|C:/|' | sed 's|/|\\|g')
            PG_ROOT_WIN=$(echo "$PG_ROOT" | sed 's|^/c/|C:/|' | sed 's|/|\\|g')
            
            # Add PostgreSQL bin directory to PATH (ensure it's first)
            export PATH="${PG_CONFIG_DIR}:${PATH}"
            
            # Set Windows-style PATH for make tools (this will be used by mingw32-make)
            export PATH_WIN="${PG_CONFIG_DIR_WIN};${PATH_WIN:-}"
            
            # Also set the regular PATH to Windows format for mingw32-make
            # Convert the entire PATH to Windows format
            PATH_WIN_FULL=$(echo "$PATH" | sed 's|^/c/|C:/|g' | sed 's|/|\\|g' | sed 's|:|;|g')
            export PATH_WIN_FULL
            
            # Create a wrapper script for pg_config in the current directory
            # This ensures mingw32-make can find pg_config even if PATH issues persist
            cat > pg_config_wrapper.sh << 'EOF'
#!/bin/bash
# Wrapper script for pg_config
exec "$PG_CONFIG" "$@"
EOF
            chmod +x pg_config_wrapper.sh
            # Add current directory to PATH so the wrapper is found
            export PATH=".:${PATH}"
            
            # Verify pg_config is accessible
            if ! command -v pg_config >/dev/null 2>&1; then
                log "Warning: pg_config not found in PATH after setup"
                log "PATH: ${PATH}"
                log "PG_CONFIG_DIR: ${PG_CONFIG_DIR}"
            else
                log "pg_config found at: $(command -v pg_config)"
            fi
            
            export PKG_CONFIG_PATH="${PG_ROOT}/lib/pkgconfig:${PKG_CONFIG_PATH:-}"
            export LDFLAGS="-L${PG_ROOT}/lib ${LDFLAGS:-}"
            export CPPFLAGS="-I${PG_ROOT}/include ${CPPFLAGS:-}"
            
            # Debug: Show PostgreSQL environment
            log "PostgreSQL environment:"
            log "  PG_CONFIG: ${PG_CONFIG}"
            log "  PG_ROOT: ${PG_ROOT}"
            log "  PATH: ${PATH}"
            log "  PKG_CONFIG_PATH: ${PKG_CONFIG_PATH}"
            
            # Try different build methods in order of preference
            # First try nmake with Makefile.win (preferred for Windows)
            log "Checking for nmake and Makefile.win..."
            log "Makefile.win exists: $([ -f "Makefile.win" ] && echo "YES" || echo "NO")"
            log "nmake available: $(command -v nmake >/dev/null 2>&1 && echo "YES" || echo "NO")"
            
            # If Makefile.win exists but nmake is not available, try to find or install it
            if [ -f "Makefile.win" ] && ! command -v nmake >/dev/null 2>&1; then
                log "Makefile.win found but nmake not available. Looking for nmake in common locations..."
                # Look for nmake in Visual Studio Build Tools locations
                for nmake_path in "/c/Program Files (x86)/Microsoft Visual Studio/2019/BuildTools/VC/Tools/MSVC/*/bin/Hostx64/x64/nmake.exe" \
                                "/c/Program Files (x86)/Microsoft Visual Studio/2022/BuildTools/VC/Tools/MSVC/*/bin/Hostx64/x64/nmake.exe" \
                                "/c/Program Files/Microsoft Visual Studio/2019/Professional/VC/Tools/MSVC/*/bin/Hostx64/x64/nmake.exe" \
                                "/c/Program Files/Microsoft Visual Studio/2022/Professional/VC/Tools/MSVC/*/bin/Hostx64/x64/nmake.exe"; do
                    if ls $nmake_path >/dev/null 2>&1; then
                        export PATH="$(dirname $(ls $nmake_path | head -1)):$PATH"
                        log "Found nmake at: $(ls $nmake_path | head -1)"
                        break
                    fi
                done
                
                # If still not found, try to install Visual Studio Build Tools
                if ! command -v nmake >/dev/null 2>&1; then
                    log "nmake not found in common locations. Attempting to install Visual Studio Build Tools..."
                    # Try to install Visual Studio Build Tools via Chocolatey
                    if command -v choco >/dev/null 2>&1; then
                        log "Installing Visual Studio Build Tools via Chocolatey..."
                        choco install visualstudio2019buildtools --package-parameters "--add Microsoft.VisualStudio.Workload.VCTools --includeRecommended --includeOptional" -y || true
                        # Refresh PATH after installation
                        export PATH="/c/Program Files (x86)/Microsoft Visual Studio/2019/BuildTools/VC/Tools/MSVC/*/bin/Hostx64/x64:$PATH"
                        
                        # Check again for nmake after installation
                        log "Checking for nmake after installation..."
                        for nmake_path in "/c/Program Files (x86)/Microsoft Visual Studio/2019/BuildTools/VC/Tools/MSVC/*/bin/Hostx64/x64/nmake.exe"; do
                            if ls $nmake_path >/dev/null 2>&1; then
                                export PATH="$(dirname $(ls $nmake_path | head -1)):$PATH"
                                log "Found nmake after installation at: $(ls $nmake_path | head -1)"
                                break
                            fi
                        done
                    else
                        log "Chocolatey not available. Cannot install nmake automatically."
                    fi
                fi
            fi
            
            if [ -f "Makefile.win" ] && command -v nmake >/dev/null 2>&1; then
                log "Using nmake with Makefile.win"
                if [ -n "$extra" ]; then
                    cmd_arr=( nmake /NOLOGO /F Makefile.win $extra $target )
                else
                    cmd_arr=( nmake /NOLOGO /F Makefile.win $target )
                fi
            # Try mingw32-make with environment variables
            elif command -v mingw32-make >/dev/null 2>&1; then
                log "Using mingw32-make with environment variables"
                # Get the full path to mingw32-make before modifying PATH
                MINGW_MAKE_PATH=$(command -v mingw32-make)
                log "Found mingw32-make at: ${MINGW_MAKE_PATH}"
                # Export environment variables for the make process
                export PG_CONFIG
                export PKG_CONFIG_PATH
                export LDFLAGS
                export CPPFLAGS
                # Set Windows-style PATH for mingw32-make
                export PATH_WIN_FULL
                log "Final PATH for make: ${PATH}"
                log "Windows PATH for mingw32-make: ${PATH_WIN_FULL}"
                if [ -n "$extra" ]; then
                    cmd_arr=( env PATH="$PATH_WIN_FULL" "$MINGW_MAKE_PATH" $extra $target )
                else
                    cmd_arr=( env PATH="$PATH_WIN_FULL" "$MINGW_MAKE_PATH" $target )
                fi
            # Try to find mingw32-make in common locations
            elif [ -f "mingw32-make.exe" ] || find . -name "mingw32-make.exe" -type f >/dev/null 2>&1; then
                log "Found mingw32-make.exe in current directory or subdirectories"
                MINGW_MAKE_PATH=$(find . -name "mingw32-make.exe" -type f | head -1)
                log "Using mingw32-make at: ${MINGW_MAKE_PATH}"
                # Export environment variables for the make process
                export PG_CONFIG
                export PKG_CONFIG_PATH
                export LDFLAGS
                export CPPFLAGS
                # Set Windows-style PATH for mingw32-make
                export PATH_WIN_FULL
                if [ -n "$extra" ]; then
                    cmd_arr=( env PATH="$PATH_WIN_FULL" "$MINGW_MAKE_PATH" $extra $target )
                else
                    cmd_arr=( env PATH="$PATH_WIN_FULL" "$MINGW_MAKE_PATH" $target )
                fi
            # Try regular make as fallback
            else
                log "Using make as fallback"
                # Export environment variables for the make process
                export PG_CONFIG
                export PKG_CONFIG_PATH
                export LDFLAGS
                export CPPFLAGS
                # Set Windows-style PATH for make
                export PATH_WIN_FULL
                log "Final PATH for make: ${PATH}"
                log "Windows PATH for make: ${PATH_WIN_FULL}"
                if [ -n "$extra" ]; then
                    cmd_arr=( env PATH="$PATH_WIN_FULL" make $extra $target )
                else
                    cmd_arr=( env PATH="$PATH_WIN_FULL" make $target )
                fi
            fi
            ;;
         macos)
             # Set up PostgreSQL development environment
             export PATH="/opt/homebrew/bin:/usr/local/bin:${PATH}"
             
             # Find and set PG_CONFIG - try multiple common locations
             PG_CONFIG_FOUND=""
             
             # Check common Homebrew locations dynamically
             for base_dir in "/opt/homebrew" "/usr/local"; do
                 if [ -d "$base_dir" ]; then
                     log "Searching for PostgreSQL in: $base_dir"
                     # Check bin directory first
                     if [ -x "$base_dir/bin/pg_config" ]; then
                         export PG_CONFIG="$base_dir/bin/pg_config"
                         PG_CONFIG_FOUND="true"
                         log "Found pg_config at: $base_dir/bin/pg_config"
                         break
                     fi
                     # Then check version-specific directories
                     if [ -d "$base_dir/opt" ]; then
                         for version_dir in $(ls -1 "$base_dir/opt" 2>/dev/null | grep -E '^postgresql@[0-9]+(\.[0-9]+)?$' | sort -V -r); do
                             pg_path="$base_dir/opt/$version_dir/bin/pg_config"
                             if [ -x "$pg_path" ]; then
                                 export PG_CONFIG="$pg_path"
                                 PG_CONFIG_FOUND="true"
                                 log "Found pg_config at: $pg_path (version: $version_dir)"
                                 break 2
                             fi
                         done
                     fi
                 fi
             done
             
             # If not found in common locations, try which command
             if [ -z "$PG_CONFIG_FOUND" ]; then
                 if command -v pg_config >/dev/null 2>&1; then
                     export PG_CONFIG="$(command -v pg_config)"
                     PG_CONFIG_FOUND="true"
                     log "Found pg_config via which: $PG_CONFIG"
                 fi
             fi
             
             # If still not found, error out
             if [ -z "$PG_CONFIG_FOUND" ]; then
                 err "pg_config not found. PostgreSQL development packages may not be installed."
                 err "Please ensure PostgreSQL is installed via Homebrew: brew install postgresql@<version>"
                 err "Searched locations: /opt/homebrew/bin, /usr/local/bin, and common PostgreSQL version paths"
                 exit 1
             fi
             
             # Set additional PostgreSQL environment variables based on PG_CONFIG location
             PG_CONFIG_DIR="$(dirname "$PG_CONFIG")"
             PG_ROOT="$(dirname "$PG_CONFIG_DIR")"
             
             export PKG_CONFIG_PATH="${PG_ROOT}/lib/pkgconfig:${PKG_CONFIG_PATH:-}"
             export LDFLAGS="-L${PG_ROOT}/lib ${LDFLAGS:-}"
             export CPPFLAGS="-I${PG_ROOT}/include ${CPPFLAGS:-}"
             
             # Find other PostgreSQL utilities
             PG_PSQL="$(find_pg_utility "psql" "$PG_CONFIG")"
             PG_ISREADY="$(find_pg_utility "pg_isready" "$PG_CONFIG")"
             PG_CREATEDB="$(find_pg_utility "createdb" "$PG_CONFIG")"
             
             # Export utility paths for use in make commands and test scripts
             if [ -n "$PG_PSQL" ]; then
                 export PG_PSQL="$PG_PSQL"
             fi
             if [ -n "$PG_ISREADY" ]; then
                 export PG_ISREADY="$PG_ISREADY"
                 # Also add to PATH so test scripts can find it
                 export PATH="$(dirname "$PG_ISREADY"):$PATH"
             fi
             if [ -n "$PG_CREATEDB" ]; then
                 export PG_CREATEDB="$PG_CREATEDB"
             fi
             
             # Debug: Show PostgreSQL environment
             log "PostgreSQL environment:"
             log "  PG_CONFIG: ${PG_CONFIG}"
             log "  PG_ROOT: ${PG_ROOT}"
             log "  PG_PSQL: ${PG_PSQL:-not found}"
             log "  PG_ISREADY: ${PG_ISREADY:-not found}"
             log "  PG_CREATEDB: ${PG_CREATEDB:-not found}"
             log "  PATH: ${PATH}"
             log "  PKG_CONFIG_PATH: ${PKG_CONFIG_PATH}"

            if [ "$target" = "install" ]; then
                if [ -n "$extra" ]; then
                    cmd_arr=( sudo -E env PATH="$PATH" PG_CONFIG="$PG_CONFIG" PKG_CONFIG_PATH="$PKG_CONFIG_PATH" LDFLAGS="$LDFLAGS" CPPFLAGS="$CPPFLAGS" PG_PSQL="${PG_PSQL:-}" PG_ISREADY="${PG_ISREADY:-}" PG_CREATEDB="${PG_CREATEDB:-}" make $extra $target )
                else
                    cmd_arr=( sudo -E env PATH="$PATH" PG_CONFIG="$PG_CONFIG" PKG_CONFIG_PATH="$PKG_CONFIG_PATH" LDFLAGS="$LDFLAGS" CPPFLAGS="$CPPFLAGS" PG_PSQL="${PG_PSQL:-}" PG_ISREADY="${PG_ISREADY:-}" PG_CREATEDB="${PG_CREATEDB:-}" make $target )
                fi
            else
                if [ -n "$extra" ]; then
                    cmd_arr=( make $extra $target )
                else
                    cmd_arr=( make $target )
                fi
            fi
            ;;
         *)
             # linux / other unix
             # Ensure pg_config is available
             if ! command -v pg_config >/dev/null 2>&1; then
                 err "pg_config not found. PostgreSQL development packages may not be installed."
                 err "Please install PostgreSQL development packages for your system."
                 exit 1
             fi
             
             if [ "$target" = "install" ]; then
                 if [ -n "$extra" ]; then
                     cmd_arr=( sudo make $extra $target )
                 else
                     cmd_arr=( sudo make $target )
                 fi
             else
                 if [ -n "$extra" ]; then
                     cmd_arr=( make $extra $target )
                 else
                     cmd_arr=( make $target )
                 fi
             fi
             ;;
    esac

    # execute
    if run_cmd "${cmd_arr[@]}"; then
        return 0
    else
        return $?
    fi
}

main() {
    local os_input="${1:-}"     # optional operating system (linux, macos, windows)
    local extra="${2:-}"        # optional extra make vars (e.g. "PGUSER=postgres")
    local rc=0

    # Parse OS and version from input
    parse_os() {
        local input="$1"
        
        # Check for specific OS versions
        case "$input" in
            ubuntu-*|debian-*|centos-*|rhel-*|fedora-*|suse-*|alpine-*)
                echo "linux"
                ;;
            macos-*|darwin-*)
                echo "macos"
                ;;
            windows-*|win-*)
                echo "windows"
                ;;
            linux|macos|windows)
                echo "$input"
                ;;
            *)
                # Auto-detect if invalid input provided
                detect_os
                ;;
        esac
    }

    OS=$(parse_os "$os_input")
    OS_VERSION="$os_input"

    if [[ "$os_input" == "linux" || "$os_input" == "macos" || "$os_input" == "windows" ]]; then
        log "Using specified operating system: $OS"
    else
        log "Using specified operating system: $OS (version: $OS_VERSION)"
    fi
    log "Starting build (make)..."
    if ! run_make "" "$extra"; then
        err "Build step failed"
        show_regression_diffs
        exit 1
    fi

    log "Installing extension (make install)..."
    if ! run_make "install" "$extra"; then
        err "Install step failed"
        show_regression_diffs
        exit 2
    fi

    # Check if PostgreSQL is ready before running tests
    if [ "$OS" = "macos" ]; then
        check_pg_ready
        
        # Ensure postgres role exists for testing
        log "Ensuring postgres role exists..."
        if [ -n "$PG_PSQL" ] && [ -x "$PG_PSQL" ]; then
            "$PG_PSQL" -d postgres -c "CREATE ROLE postgres WITH LOGIN SUPERUSER CREATEDB CREATEROLE;" 2>/dev/null || log "postgres role already exists or creation failed"
        elif command -v psql >/dev/null 2>&1; then
            psql -d postgres -c "CREATE ROLE postgres WITH LOGIN SUPERUSER CREATEDB CREATEROLE;" 2>/dev/null || log "postgres role already exists or creation failed"
        fi
    fi
    
    log "Running tests (make installcheck)..."
    # If extra is empty, default to PGUSER=postgres for installcheck
    local ic_extra="${extra:-PGUSER=postgres}"
    if ! run_make "installcheck" "$ic_extra"; then
        err "installcheck failed"
        show_regression_diffs
        exit 3
    fi

    ok "All steps completed successfully (build / install / installcheck)"
    exit 0
}

# Entry: optional single argument string passed to make as extra vars
main "${1:-}"
