#!/usr/bin/env bash
# build-check
# Run a build / install / installcheck sequence for the PostgreSQL extension.
#
# Usage: build-check [MAKE_ARGS]
# Example: build-check "PGUSER=postgres"
#
# Behavior:
#  - Detect OS (linux|macos|windows)
#  - Run build (make or nmake)
#  - Run install (sudo make install) if available
#  - Run installcheck (with optional extra vars, e.g. PGUSER=postgres)
#  - On failure, print regression.diffs (if present) and return non-zero exit code
#
# This script is intended for CI runners (GitHub Actions). It avoids printing
# misleading messages and returns the real status of the test run.

set -euo pipefail
IFS=$'\n\t'

# ---- helpers ----
log()  { printf '\033[1;34m[build-check]\033[0m %s\n' "$*"; }
die()  { printf '\033[1;31m[build-check]\033[0m %s\n' "$*" >&2; exit 1; }
ok()   { printf '\033[1;32m[build-check]\033[0m %s\n' "$*"; }

detect_os() {
    case "$(uname -s)" in
        Linux*)  echo "linux" ;;
        Darwin*) echo "macos" ;;
        CYGWIN*|MINGW*|MSYS*) echo "windows" ;;
        *)       echo "unknown" ;;
    esac
}

# run a command (array) and fail with message if it fails
run_cmd() {
    local -a cmd=( "$@" )
    log "Running: ${cmd[*]}"
    if "${cmd[@]}"; then
        ok "Command succeeded"
        return 0
    else
        die "Command failed: ${cmd[*]}"
    fi
}

# run make in a cross-platform aware way
# args:
#   $1 = target (empty string for default)
#   $2 = extra (optional) e.g. "PGUSER=postgres"
run_make() {
    local target="${1:-}"   # may be empty
    local extra="${2:-}"    # may be empty
    local os="$3"           # pass detected OS if you want (optional)
    local cmd_arr
    os="${os:-$(detect_os)}"

    case "$os" in
        windows)
            # Prefer Makefile.win / nmake if available (GitHub windows runners have nmake)
            if [ -f "Makefile.win" ] && command -v nmake >/dev/null 2>&1; then
                if [ -n "$extra" ]; then
                    cmd_arr=( nmake /NOLOGO /F Makefile.win $extra $target )
                else
                    cmd_arr=( nmake /NOLOGO /F Makefile.win $target )
                fi
            else
                # fallback to mingw32-make or make
                if command -v mingw32-make >/dev/null 2>&1; then
                    cmd_arr=( mingw32-make $extra $target )
                else
                    cmd_arr=( make $extra $target )
                fi
            fi
            ;;
        macos)
            # Ensure we use a Homebrew-installed pg_config if present
            if [ -x "/opt/homebrew/bin/pg_config" ]; then
                export PG_CONFIG="/opt/homebrew/bin/pg_config"
            elif [ -x "/usr/local/bin/pg_config" ]; then
                export PG_CONFIG="/usr/local/bin/pg_config"
            fi

            # Add common Homebrew paths for macOS CI
            export PATH="/opt/homebrew/bin:/usr/local/bin:${PATH}"
            export PKG_CONFIG_PATH="/opt/homebrew/lib/pkgconfig:/usr/local/lib/pkgconfig:${PKG_CONFIG_PATH:-}"
            export LDFLAGS="-L/opt/homebrew/lib -L/usr/local/lib ${LDFLAGS:-}"
            export CPPFLAGS="-I/opt/homebrew/include -I/usr/local/include ${CPPFLAGS:-}"

            # Use sudo for install target on macOS
            if [ "$target" = "install" ]; then
                if [ -n "$extra" ]; then
                    cmd_arr=( sudo make $extra $target )
                else
                    cmd_arr=( sudo make $target )
                fi
            else
                if [ -n "$extra" ]; then
                    cmd_arr=( make $extra $target )
                else
                    cmd_arr=( make $target )
                fi
            fi
            ;;
        *)
            # linux / Unix
            if [ "$target" = "install" ]; then
                if [ -n "$extra" ]; then
                    cmd_arr=( sudo make $extra $target )
                else
                    cmd_arr=( sudo make $target )
                fi
            else
                if [ -n "$extra" ]; then
                    cmd_arr=( make $extra $target )
                else
                    cmd_arr=( make $target )
                fi
            fi
            ;;
    esac

    log "Invoking: ${cmd_arr[*]}"
    if "${cmd_arr[@]}"; then
        ok "make target '$target' succeeded"
        return 0
    else
        # return the failing command's exit code (captured automatically via set -e is off here)
        local rc=$?
        die "make target '$target' failed with exit code $rc"
        return $rc
    fi
}

# show regression diffs if present
show_regression_diffs() {
    if [ -f regression.diffs ]; then
        echo
        echo "===================== regression.diffs ====================="
        sed -n '1,200p' regression.diffs || true
        echo "==========================================================="
    else
        log "No regression.diffs file found"
    fi
}

# ---- main flow ----
main() {
    local extra_arg="${1:-}"   # optional extra make variables (e.g. "PGUSER=postgres")
    local os
    os="$(detect_os)"
    log "Detected OS: $os"

    # 1) build
    log "STEP 1/3: build (make)"
    run_make "" "$extra_arg" "$os" || { show_regression_diffs; exit 1; }

    # 2) install
    log "STEP 2/3: install (make install)"
    # try install; allow it to fail in a way we report clearly
    if ! run_make "install" "$extra_arg" "$os"; then
        die "Install step failed; aborting further checks"
    fi

    # 3) installcheck (tests)
    log "STEP 3/3: installcheck (make installcheck)"
    # Recommended to pass PGUSER=postgres from CI; allow extra_arg to include this.
    local installcheck_extra="${extra_arg:-PGUSER=postgres}"
    if ! run_make "installcheck" "$installcheck_extra" "$os"; then
        log "installcheck failed; printing regression.diffs (if available)"
        show_regression_diffs
        exit 2
    fi

    ok "All build + install + installcheck steps completed successfully"
    exit 0
}

# Entry point:
# Accept one optional argument: string with extra make variables (e.g. "PGUSER=postgres")
# In many CI usages you'll pass PGUSER=postgres as the argument.
main "${1:-}"
