#!/usr/bin/env bash
# test/bin/build-check
# Robust cross-platform build / install / installcheck wrapper for PostgreSQL extensions.
#
# Usage:
#   test/bin/build-check [OPERATING_SYSTEM] [EXTRA_MAKE_VARS]
# Example:
#   test/bin/build-check "linux" "PGUSER=postgres"
#   test/bin/build-check "macos"
#
# Behavior:
# - Uses specified OS or auto-detects (linux|macos|windows).
# - Runs: make -> make install -> make installcheck (with EXTRA_MAKE_VARS).
# - On failure prints regression.diffs (if present) and exits non-zero.
# - On success exits 0 and prints success messages only.
#
set -euo pipefail
IFS=$'\n\t'

log()  { printf '\033[1;34m[build-check]\033[0m %s\n' "$*"; }
ok()   { printf '\033[1;32m[build-check]\033[0m %s\n' "$*"; }
err()  { printf '\033[1;31m[build-check]\033[0m %s\n' "$*"; }

detect_os() {
    case "$(uname -s)" in
        Linux*)  echo "linux" ;;
        Darwin*) echo "macos" ;;
        CYGWIN*|MINGW*|MSYS*) echo "windows" ;;
        *)       echo "unknown" ;;
    esac
}

# Find PostgreSQL utilities (pg_config, psql, pg_isready, etc.)
find_pg_utility() {
    local utility="$1"
    local pg_config_path="$2"
    
    if [ -z "$pg_config_path" ]; then
        # If no pg_config path provided, try common locations
        for pg_path in "/opt/homebrew/bin/$utility" "/usr/local/bin/$utility" "/opt/homebrew/opt/postgresql@14/bin/$utility" "/opt/homebrew/opt/postgresql@15/bin/$utility" "/opt/homebrew/opt/postgresql@16/bin/$utility" "/opt/homebrew/opt/postgresql@17/bin/$utility"; do
            if [ -x "$pg_path" ]; then
                echo "$pg_path"
                return 0
            fi
        done
        
        # Try which command as fallback
        if command -v "$utility" >/dev/null 2>&1; then
            command -v "$utility"
            return 0
        fi
    else
        # Use pg_config location to find other utilities
        local pg_bin_dir="$(dirname "$pg_config_path")"
        local pg_util_path="$pg_bin_dir/$utility"
        
        if [ -x "$pg_util_path" ]; then
            echo "$pg_util_path"
            return 0
        fi
    fi
    
    return 1
}

# Check if PostgreSQL is ready to accept connections
check_pg_ready() {
    local max_attempts=30
    local attempt=1
    
    log "Checking if PostgreSQL is ready..."
    
    while [ $attempt -le $max_attempts ]; do
        if [ -n "$PG_ISREADY" ] && [ -x "$PG_ISREADY" ]; then
            if "$PG_ISREADY" -q; then
                ok "PostgreSQL is ready (attempt $attempt/$max_attempts)"
                return 0
            fi
        elif command -v pg_isready >/dev/null 2>&1; then
            if pg_isready -q; then
                ok "PostgreSQL is ready (attempt $attempt/$max_attempts)"
                return 0
            fi
        else
            # Fallback: try to connect with psql
            if [ -n "$PG_PSQL" ] && [ -x "$PG_PSQL" ]; then
                if "$PG_PSQL" -c "SELECT 1;" >/dev/null 2>&1; then
                    ok "PostgreSQL is ready (attempt $attempt/$max_attempts)"
                    return 0
                fi
            elif command -v psql >/dev/null 2>&1; then
                if psql -c "SELECT 1;" >/dev/null 2>&1; then
                    ok "PostgreSQL is ready (attempt $attempt/$max_attempts)"
                    return 0
                fi
            fi
        fi
        
        log "PostgreSQL not ready yet, waiting... (attempt $attempt/$max_attempts)"
        sleep 2
        attempt=$((attempt + 1))
    done
    
    err "PostgreSQL is not ready after $max_attempts attempts"
    return 1
}

show_regression_diffs() {
    if [ -f regression.diffs ]; then
        echo
        echo "===================== regression.diffs ====================="
        sed -n '1,400p' regression.diffs || true
        echo "==========================================================="
    else
        log "No regression.diffs file found"
    fi
}

# run a command (array) and return its exit code (prints helpful logs)
run_cmd() {
    local -a cmd=( "$@" )
    log "Running: ${cmd[*]}"
    if "${cmd[@]}"; then
        ok "Command succeeded: ${cmd[*]}"
        return 0
    else
        local rc=$?
        err "Command failed (exit ${rc}): ${cmd[*]}"
        return $rc
    fi
}

# run make in a cross-platform way
# $1 = target (empty string for default build)
# $2 = extra vars (single string, e.g. "PGUSER=postgres")
run_make() {
    local target="${1:-}"    # may be empty
    local extra="${2:-}"     # may be empty
    local cmd_arr

    case "$OS" in
        windows)
            if [ -f "Makefile.win" ] && command -v nmake >/dev/null 2>&1; then
                if [ -n "$extra" ]; then
                    cmd_arr=( nmake /NOLOGO /F Makefile.win $extra $target )
                else
                    cmd_arr=( nmake /NOLOGO /F Makefile.win $target )
                fi
            elif command -v mingw32-make >/dev/null 2>&1; then
                if [ -n "$extra" ]; then
                    cmd_arr=( mingw32-make $extra $target )
                else
                    cmd_arr=( mingw32-make $target )
                fi
            else
                if [ -n "$extra" ]; then
                    cmd_arr=( make $extra $target )
                else
                    cmd_arr=( make $target )
                fi
            fi
            ;;
         macos)
             # Set up PostgreSQL development environment
             export PATH="/opt/homebrew/bin:/usr/local/bin:${PATH}"
             
             # Find and set PG_CONFIG - try multiple common locations
             PG_CONFIG_FOUND=""
             
             # Check common Homebrew locations
             for pg_path in "/opt/homebrew/bin/pg_config" "/usr/local/bin/pg_config" "/opt/homebrew/opt/postgresql@14/bin/pg_config" "/opt/homebrew/opt/postgresql@15/bin/pg_config" "/opt/homebrew/opt/postgresql@16/bin/pg_config" "/opt/homebrew/opt/postgresql@17/bin/pg_config"; do
                 if [ -x "$pg_path" ]; then
                     export PG_CONFIG="$pg_path"
                     PG_CONFIG_FOUND="true"
                     log "Found pg_config at: $pg_path"
                     break
                 fi
             done
             
             # If not found in common locations, try which command
             if [ -z "$PG_CONFIG_FOUND" ]; then
                 if command -v pg_config >/dev/null 2>&1; then
                     export PG_CONFIG="$(command -v pg_config)"
                     PG_CONFIG_FOUND="true"
                     log "Found pg_config via which: $PG_CONFIG"
                 fi
             fi
             
             # If still not found, error out
             if [ -z "$PG_CONFIG_FOUND" ]; then
                 err "pg_config not found. PostgreSQL development packages may not be installed."
                 err "Please ensure PostgreSQL is installed via Homebrew: brew install postgresql@<version>"
                 err "Searched locations: /opt/homebrew/bin, /usr/local/bin, and common PostgreSQL version paths"
                 exit 1
             fi
             
             # Set additional PostgreSQL environment variables based on PG_CONFIG location
             PG_CONFIG_DIR="$(dirname "$PG_CONFIG")"
             PG_ROOT="$(dirname "$PG_CONFIG_DIR")"
             
             export PKG_CONFIG_PATH="${PG_ROOT}/lib/pkgconfig:${PKG_CONFIG_PATH:-}"
             export LDFLAGS="-L${PG_ROOT}/lib ${LDFLAGS:-}"
             export CPPFLAGS="-I${PG_ROOT}/include ${CPPFLAGS:-}"
             
             # Find other PostgreSQL utilities
             PG_PSQL="$(find_pg_utility "psql" "$PG_CONFIG")"
             PG_ISREADY="$(find_pg_utility "pg_isready" "$PG_CONFIG")"
             PG_CREATEDB="$(find_pg_utility "createdb" "$PG_CONFIG")"
             
             # Export utility paths for use in make commands
             if [ -n "$PG_PSQL" ]; then
                 export PG_PSQL="$PG_PSQL"
             fi
             if [ -n "$PG_ISREADY" ]; then
                 export PG_ISREADY="$PG_ISREADY"
             fi
             if [ -n "$PG_CREATEDB" ]; then
                 export PG_CREATEDB="$PG_CREATEDB"
             fi
             
             # Debug: Show PostgreSQL environment
             log "PostgreSQL environment:"
             log "  PG_CONFIG: ${PG_CONFIG}"
             log "  PG_ROOT: ${PG_ROOT}"
             log "  PG_PSQL: ${PG_PSQL:-not found}"
             log "  PG_ISREADY: ${PG_ISREADY:-not found}"
             log "  PG_CREATEDB: ${PG_CREATEDB:-not found}"
             log "  PATH: ${PATH}"
             log "  PKG_CONFIG_PATH: ${PKG_CONFIG_PATH}"

            if [ "$target" = "install" ]; then
                if [ -n "$extra" ]; then
                    cmd_arr=( sudo -E env PG_CONFIG="$PG_CONFIG" PKG_CONFIG_PATH="$PKG_CONFIG_PATH" LDFLAGS="$LDFLAGS" CPPFLAGS="$CPPFLAGS" PG_PSQL="${PG_PSQL:-}" PG_ISREADY="${PG_ISREADY:-}" PG_CREATEDB="${PG_CREATEDB:-}" make $extra $target )
                else
                    cmd_arr=( sudo -E env PG_CONFIG="$PG_CONFIG" PKG_CONFIG_PATH="$PKG_CONFIG_PATH" LDFLAGS="$LDFLAGS" CPPFLAGS="$CPPFLAGS" PG_PSQL="${PG_PSQL:-}" PG_ISREADY="${PG_ISREADY:-}" PG_CREATEDB="${PG_CREATEDB:-}" make $target )
                fi
            else
                if [ -n "$extra" ]; then
                    cmd_arr=( make $extra $target )
                else
                    cmd_arr=( make $target )
                fi
            fi
            ;;
         *)
             # linux / other unix
             # Ensure pg_config is available
             if ! command -v pg_config >/dev/null 2>&1; then
                 err "pg_config not found. PostgreSQL development packages may not be installed."
                 err "Please install PostgreSQL development packages for your system."
                 exit 1
             fi
             
             if [ "$target" = "install" ]; then
                 if [ -n "$extra" ]; then
                     cmd_arr=( sudo make $extra $target )
                 else
                     cmd_arr=( sudo make $target )
                 fi
             else
                 if [ -n "$extra" ]; then
                     cmd_arr=( make $extra $target )
                 else
                     cmd_arr=( make $target )
                 fi
             fi
             ;;
    esac

    # execute
    if run_cmd "${cmd_arr[@]}"; then
        return 0
    else
        return $?
    fi
}

main() {
    local os_input="${1:-}"     # optional operating system (linux, macos, windows)
    local extra="${2:-}"        # optional extra make vars (e.g. "PGUSER=postgres")
    local rc=0

    # Parse OS and version from input
    parse_os() {
        local input="$1"
        
        # Check for specific OS versions
        case "$input" in
            ubuntu-*|debian-*|centos-*|rhel-*|fedora-*|suse-*|alpine-*)
                echo "linux"
                ;;
            macos-*|darwin-*)
                echo "macos"
                ;;
            windows-*|win-*)
                echo "windows"
                ;;
            linux|macos|windows)
                echo "$input"
                ;;
            *)
                # Auto-detect if invalid input provided
                detect_os
                ;;
        esac
    }

    OS=$(parse_os "$os_input")
    OS_VERSION="$os_input"

    if [[ "$os_input" == "linux" || "$os_input" == "macos" || "$os_input" == "windows" ]]; then
        log "Using specified operating system: $OS"
    else
        log "Using specified operating system: $OS (version: $OS_VERSION)"
    fi
    log "Starting build (make)..."
    if ! run_make "" "$extra"; then
        err "Build step failed"
        show_regression_diffs
        exit 1
    fi

    log "Installing extension (make install)..."
    if ! run_make "install" "$extra"; then
        err "Install step failed"
        show_regression_diffs
        exit 2
    fi

    # Check if PostgreSQL is ready before running tests
    if [ "$OS" = "macos" ]; then
        check_pg_ready
    fi
    
    log "Running tests (make installcheck)..."
    # If extra is empty, default to PGUSER=postgres for installcheck
    local ic_extra="${extra:-PGUSER=postgres}"
    if ! run_make "installcheck" "$ic_extra"; then
        err "installcheck failed"
        show_regression_diffs
        exit 3
    fi

    ok "All steps completed successfully (build / install / installcheck)"
    exit 0
}

# Entry: optional single argument string passed to make as extra vars
main "${1:-}"
