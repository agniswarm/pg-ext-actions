#!/usr/bin/env bash
# test/bin/build-check
# Robust cross-platform build / install / installcheck wrapper for PostgreSQL extensions.
#
# Usage:
#   test/bin/build-check [OPERATING_SYSTEM] [EXTRA_MAKE_VARS]
# Example:
#   test/bin/build-check "linux" "PGUSER=postgres"
#   test/bin/build-check "macos"
#
# Behavior:
# - Uses specified OS or auto-detects (linux|macos|windows).
# - Runs: make -> make install -> make installcheck (with EXTRA_MAKE_VARS).
# - On failure prints regression.diffs (if present) and exits non-zero.
# - On success exits 0 and prints success messages only.
#
set -euo pipefail
IFS=$'\n\t'

log()  { printf '\033[1;34m[build-check]\033[0m %s\n' "$*" >&2; }
ok()   { printf '\033[1;32m[build-check]\033[0m %s\n' "$*" >&2; }
err()  { printf '\033[1;31m[build-check]\033[0m %s\n' "$*" >&2; }

detect_os() {
    case "$(uname -s)" in
        Linux*)  echo "linux" ;;
        Darwin*) echo "macos" ;;
        CYGWIN*|MINGW*|MSYS*) echo "windows" ;;
        *)       echo "unknown" ;;
    esac
}

# Find PostgreSQL utilities (pg_config, psql, pg_isready, etc.)
find_pg_utility() {
    local utility="$1"
    local pg_config_path="$2"
    
    if [ -z "$pg_config_path" ]; then
        # If no pg_config path provided, try common locations dynamically
        for base_dir in "/opt/homebrew" "/usr/local"; do
            if [ -d "$base_dir" ]; then
                # Check bin directory first
                if [ -x "$base_dir/bin/$utility" ]; then
                    echo "$base_dir/bin/$utility"
                    return 0
                fi
                # Then check version-specific directories
                if [ -d "$base_dir/opt" ]; then
                    for version_dir in $(ls -1 "$base_dir/opt" 2>/dev/null | grep -E '^postgresql@[0-9]+(\.[0-9]+)?$' | sort -V -r); do
                        pg_path="$base_dir/opt/$version_dir/bin/$utility"
                        if [ -x "$pg_path" ]; then
                            echo "$pg_path"
                            return 0
                        fi
                    done
                fi
            fi
        done
        
        # Try which command as fallback
        if command -v "$utility" >/dev/null 2>&1; then
            command -v "$utility"
            return 0
        fi
    else
        # Use pg_config location to find other utilities
        local pg_bin_dir="$(dirname "$pg_config_path")"
        local pg_util_path="$pg_bin_dir/$utility"
        
        if [ -x "$pg_util_path" ]; then
            echo "$pg_util_path"
            return 0
        fi
    fi
    
    return 1
}

# Windows-specific tool detection functions
detect_windows_build_tools() {
    local preferred_tool="${1:-}"  # optional preferred tool (mingw32-make, nmake, make)
    local found_tool=""
    local tool_path=""
    local tool_dir=""
    
    log "Detecting Windows build tools..."
    
    # If a preferred tool is specified, try it first
    if [ -n "$preferred_tool" ]; then
        log "User requested specific tool: $preferred_tool"
        case "$preferred_tool" in
            "mingw32-make")
                # Check for mingw32-make first
                for mingw_pattern in \
                    "/c/msys64/mingw64/bin/mingw32-make.exe" \
                    "/c/msys64/usr/bin/mingw32-make.exe" \
                    "/c/tools/msys64/mingw64/bin/mingw32-make.exe"; do
                    
                    if [ -x "$mingw_pattern" ]; then
                        tool_path="$mingw_pattern"
                        found_tool="mingw32-make"
                        tool_dir="$(dirname "$tool_path")"
                        log "Found requested mingw32-make: $tool_path"
                        break
                    fi
                done
                
                # Try command -v as fallback
                if [ -z "$found_tool" ] && command -v mingw32-make >/dev/null 2>&1; then
                    tool_path=$(command -v mingw32-make)
                    found_tool="mingw32-make"
                    tool_dir="$(dirname "$tool_path")"
                    log "Found requested mingw32-make via command -v: $tool_path"
                fi
                ;;
            "nmake")
                # Check for nmake first
                local vswhere_path="/c/Program Files (x86)/Microsoft Visual Studio/Installer/vswhere.exe"
                if [ -x "$vswhere_path" ]; then
                    log "Using vswhere.exe to locate requested nmake..."
                    local nmake_paths
                    nmake_paths=$(powershell -Command "& '$vswhere_path' -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -find '**\\nmake.exe'" 2>/dev/null)
                    
                    if [ -n "$nmake_paths" ]; then
                        tool_path=$(echo "$nmake_paths" | head -1)
                        if [ -x "$tool_path" ]; then
                            found_tool="nmake"
                            tool_dir="$(dirname "$tool_path")"
                            log "Found requested nmake via vswhere: $tool_path"
                        fi
                    fi
                fi
                
                # If vswhere didn't find it, try common locations
                if [ -z "$found_tool" ]; then
                    for vs_base in \
                        "/c/Program Files (x86)/Microsoft Visual Studio" \
                        "/c/Program Files/Microsoft Visual Studio"; do
                        
                        if [ -d "$vs_base" ]; then
                            for vs_version in "2019" "2022" "2017"; do
                                for vs_edition in "BuildTools" "Professional" "Community" "Enterprise"; do
                                    for arch in "Hostx64/x64" "Hostx86/x64"; do
                                        nmake_pattern="$vs_base/$vs_version/$vs_edition/VC/Tools/MSVC/*/bin/$arch/nmake.exe"
                                        if ls $nmake_pattern >/dev/null 2>&1; then
                                            tool_path=$(ls $nmake_pattern | head -1)
                                            if [ -x "$tool_path" ]; then
                                                found_tool="nmake"
                                                tool_dir="$(dirname "$tool_path")"
                                                log "Found requested nmake in Visual Studio: $tool_path"
                                                break 4
                                            fi
                                        fi
                                    done
                                done
                            done
                        fi
                    done
                fi
                
                # Try command -v as fallback
                if [ -z "$found_tool" ] && command -v nmake >/dev/null 2>&1; then
                    tool_path=$(command -v nmake)
                    found_tool="nmake"
                    tool_dir="$(dirname "$tool_path")"
                    log "Found requested nmake via command -v: $tool_path"
                fi
                ;;
            "make")
                # Check for make first
                for make_pattern in \
                    "/c/Program Files/Git/usr/bin/make.exe" \
                    "/c/msys64/usr/bin/make.exe"; do
                    
                    if [ -x "$make_pattern" ]; then
                        tool_path="$make_pattern"
                        found_tool="make"
                        tool_dir="$(dirname "$tool_path")"
                        log "Found requested make: $tool_path"
                        break
                    fi
                done
                
                # Try command -v as fallback
                if [ -z "$found_tool" ] && command -v make >/dev/null 2>&1; then
                    tool_path=$(command -v make)
                    found_tool="make"
                    tool_dir="$(dirname "$tool_path")"
                    log "Found requested make via command -v: $tool_path"
                fi
                ;;
            *)
                log "Unknown preferred tool: $preferred_tool, falling back to default detection"
                ;;
        esac
        
        # If preferred tool was found, return it
        if [ -n "$found_tool" ]; then
            log "Using user-requested tool: $found_tool at $tool_path"
            
            # Add tool directory to PATH if not already there
            if [ -n "$tool_dir" ] && [[ ":$PATH:" != *":$tool_dir:"* ]]; then
                export PATH="$tool_dir:$PATH"
                log "Added $tool_dir to PATH"
                
                # Also add to GITHUB_PATH for persistence
                if [ -n "$GITHUB_PATH" ]; then
                    echo "$tool_dir" >> "$GITHUB_PATH"
                    log "Added $tool_dir to GITHUB_PATH"
                fi
            fi
            
            # Output only the result
            echo "$found_tool|$tool_path"
            return 0
        else
            log "Requested tool '$preferred_tool' not found, falling back to default detection"
        fi
    fi
    
    # 1. Check for mingw32-make.exe (highest priority)
    log "Checking for mingw32-make.exe..."
    
    for mingw_pattern in \
        "/c/msys64/mingw64/bin/mingw32-make.exe" \
        "/c/msys64/usr/bin/mingw32-make.exe" \
        "/c/tools/msys64/mingw64/bin/mingw32-make.exe"; do
        
        if [ -x "$mingw_pattern" ]; then
            tool_path="$mingw_pattern"
            found_tool="mingw32-make"
            tool_dir="$(dirname "$tool_path")"
            log "Found mingw32-make: $tool_path"
            break
        fi
    done
    
    # Try command -v as fallback
    if [ -z "$found_tool" ] && command -v mingw32-make >/dev/null 2>&1; then
        tool_path=$(command -v mingw32-make)
        found_tool="mingw32-make"
        tool_dir="$(dirname "$tool_path")"
        log "Found mingw32-make via command -v: $tool_path"
    fi
    
    # 2. Check for nmake.exe (second priority) - only if mingw32-make not found
    if [ -z "$found_tool" ]; then
        log "Checking for nmake.exe..."
        
        # First try vswhere.exe to find Visual Studio installations
        local vswhere_path="/c/Program Files (x86)/Microsoft Visual Studio/Installer/vswhere.exe"
        if [ -x "$vswhere_path" ]; then
            log "Using vswhere.exe to locate nmake..."
            local nmake_paths
            nmake_paths=$(powershell -Command "& '$vswhere_path' -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -find '**\\nmake.exe'" 2>/dev/null)
            
            if [ -n "$nmake_paths" ]; then
                # Take the first result
                tool_path=$(echo "$nmake_paths" | head -1)
                if [ -x "$tool_path" ]; then
                    found_tool="nmake"
                    tool_dir="$(dirname "$tool_path")"
                    log "Found nmake via vswhere: $tool_path"
                fi
            fi
        fi
        
        # If vswhere didn't find it, try common locations more aggressively
        if [ -z "$found_tool" ]; then
            log "Searching for nmake in Visual Studio installations..."
            for vs_base in \
                "/c/Program Files (x86)/Microsoft Visual Studio" \
                "/c/Program Files/Microsoft Visual Studio"; do
                
                if [ -d "$vs_base" ]; then
                    log "Checking Visual Studio installation at: $vs_base"
                    for vs_version in "2019" "2022" "2017"; do
                        for vs_edition in "BuildTools" "Professional" "Community" "Enterprise"; do
                            for arch in "Hostx64/x64" "Hostx86/x64"; do
                                nmake_pattern="$vs_base/$vs_version/$vs_edition/VC/Tools/MSVC/*/bin/$arch/nmake.exe"
                                if ls $nmake_pattern >/dev/null 2>&1; then
                                    tool_path=$(ls $nmake_pattern | head -1)
                                    if [ -x "$tool_path" ]; then
                                        found_tool="nmake"
                                        tool_dir="$(dirname "$tool_path")"
                                        log "Found nmake in Visual Studio: $tool_path"
                                        break 4
                                    fi
                                fi
                            done
                        done
                    done
                fi
            done
        fi
        
        # Try command -v as fallback
        if [ -z "$found_tool" ] && command -v nmake >/dev/null 2>&1; then
            tool_path=$(command -v nmake)
            found_tool="nmake"
            tool_dir="$(dirname "$tool_path")"
            log "Found nmake via command -v: $tool_path"
        fi
    fi
    
    # 3. Check for make.exe (fallback) - only if nmake and mingw32-make not found
    if [ -z "$found_tool" ]; then
        log "Checking for make.exe..."
        
        for make_pattern in \
            "/c/Program Files/Git/usr/bin/make.exe" \
            "/c/msys64/usr/bin/make.exe"; do
            
            if [ -x "$make_pattern" ]; then
                tool_path="$make_pattern"
                found_tool="make"
                tool_dir="$(dirname "$tool_path")"
                log "Found make: $tool_path"
                break
            fi
        done
        
        # Try command -v as fallback
        if [ -z "$found_tool" ] && command -v make >/dev/null 2>&1; then
            tool_path=$(command -v make)
            found_tool="make"
            tool_dir="$(dirname "$tool_path")"
            log "Found make via command -v: $tool_path"
        fi
    fi
    
    # 4. If still no tool found, try to install Visual Studio Build Tools for nmake
    if [ -z "$found_tool" ]; then
        log "No build tools found. Attempting to install Visual Studio Build Tools for nmake..."
        
        # Try to install Visual Studio Build Tools via Chocolatey
        if command -v choco >/dev/null 2>&1; then
            log "Installing Visual Studio Build Tools via Chocolatey..."
            choco install visualstudio2019buildtools --package-parameters "--add Microsoft.VisualStudio.Component.VC.Tools --includeRecommended --includeOptional" -y || true
            
            # Wait for installation to complete
            sleep 10
            
            # Check again for nmake after installation
            log "Checking for nmake after installation..."
            for nmake_pattern in \
                "/c/Program Files (x86)/Microsoft Visual Studio/2019/BuildTools/VC/Tools/MSVC/*/bin/Hostx64/x64/nmake.exe" \
                "/c/Program Files (x86)/Microsoft Visual Studio/2022/BuildTools/VC/Tools/MSVC/*/bin/Hostx64/x64/nmake.exe"; do
                
                if ls $nmake_pattern >/dev/null 2>&1; then
                    tool_path=$(ls $nmake_pattern | head -1)
                    if [ -x "$tool_path" ]; then
                        found_tool="nmake"
                        tool_dir="$(dirname "$tool_path")"
                        log "Found nmake after installation: $tool_path"
                        break
                    fi
                fi
            done
        else
            log "Chocolatey not available. Cannot install nmake automatically."
        fi
    fi
    
    if [ -n "$found_tool" ]; then
        log "Selected build tool: $found_tool at $tool_path"
        
        # Add tool directory to PATH if not already there
        if [ -n "$tool_dir" ] && [[ ":$PATH:" != *":$tool_dir:"* ]]; then
            export PATH="$tool_dir:$PATH"
            log "Added $tool_dir to PATH"
            
            # Also add to GITHUB_PATH for persistence
            if [ -n "$GITHUB_PATH" ]; then
                echo "$tool_dir" >> "$GITHUB_PATH"
                log "Added $tool_dir to GITHUB_PATH"
            fi
        fi
        
        # Output only the result
        echo "$found_tool|$tool_path"
        return 0
    else
        err "No build tools found (nmake, mingw32-make, or make)"
        return 1
    fi
}

# Check if PostgreSQL is ready to accept connections
check_pg_ready() {
    local max_attempts=30
    local attempt=1
    
    log "Checking if PostgreSQL is ready..."
    
    while [ $attempt -le $max_attempts ]; do
        if [ -n "$PG_ISREADY" ] && [ -x "$PG_ISREADY" ]; then
            if "$PG_ISREADY" -q; then
                ok "PostgreSQL is ready (attempt $attempt/$max_attempts)"
                return 0
            fi
        elif command -v pg_isready >/dev/null 2>&1; then
            if pg_isready -q; then
                ok "PostgreSQL is ready (attempt $attempt/$max_attempts)"
                return 0
            fi
        else
            # Fallback: try to connect with psql
            if [ -n "$PG_PSQL" ] && [ -x "$PG_PSQL" ]; then
                if "$PG_PSQL" -c "SELECT 1;" >/dev/null 2>&1; then
                    ok "PostgreSQL is ready (attempt $attempt/$max_attempts)"
                    return 0
                fi
            elif command -v psql >/dev/null 2>&1; then
                if psql -c "SELECT 1;" >/dev/null 2>&1; then
                    ok "PostgreSQL is ready (attempt $attempt/$max_attempts)"
                    return 0
                fi
            fi
        fi
        
        log "PostgreSQL not ready yet, waiting... (attempt $attempt/$max_attempts)"
        sleep 2
        attempt=$((attempt + 1))
    done
    
    err "PostgreSQL is not ready after $max_attempts attempts"
    return 1
}

show_regression_diffs() {
    if [ -f regression.diffs ]; then
        echo
        echo "===================== regression.diffs ====================="
        sed -n '1,400p' regression.diffs || true
        echo "==========================================================="
    else
        log "No regression.diffs file found"
    fi
}

# run a command (array) and return its exit code (prints helpful logs)
run_cmd() {
    local -a cmd=( "$@" )
    log "Running: ${cmd[*]}"
    if "${cmd[@]}"; then
        ok "Command succeeded: ${cmd[*]}"
        return 0
    else
        local rc=$?
        err "Command failed (exit ${rc}): ${cmd[*]}"
        return $rc
    fi
}

# run make in a cross-platform way
# $1 = target (empty string for default build)
# $2 = extra vars (single string, e.g. "PGUSER=postgres")
run_make() {
    local target="${1:-}"    # may be empty
    local extra="${2:-}"     # may be empty
    local make_tool="${3:-}" # optional make tool for Windows
    local cmd_arr

        case "$OS" in
            windows)
                # Detect and set up build tools
                local build_tool_info
                if ! build_tool_info=$(detect_windows_build_tools "$make_tool"); then
                    err "Failed to detect any build tools on Windows"
                    exit 1
                fi
            
            # Parse tool info (tool_name|tool_path)
            local build_tool="${build_tool_info%|*}"
            local build_tool_path="${build_tool_info#*|}"
            
            log "Using build tool: $build_tool at $build_tool_path"
            
            # Find PostgreSQL installation dynamically
            PG_CONFIG_FOUND=""
            
            # First, try to find any PostgreSQL installation in common locations
            for pg_dir in "/c/Program Files/PostgreSQL" "/c/Program Files (x86)/PostgreSQL"; do
                if [ -d "$pg_dir" ]; then
                    log "Searching for PostgreSQL in: $pg_dir"
                    # Find the highest version number (most recent installation)
                    for version_dir in $(ls -1 "$pg_dir" 2>/dev/null | grep -E '^[0-9]+(\.[0-9]+)?$' | sort -V -r); do
                        pg_path="$pg_dir/$version_dir/bin/pg_config"
                        if [ -x "$pg_path" ]; then
                            export PG_CONFIG="$pg_path"
                            PG_CONFIG_FOUND="true"
                            log "Found pg_config at: $pg_path (version: $version_dir)"
                            break 2
                        fi
                    done
                fi
            done
            
            # If not found in common locations, try which command
            if [ -z "$PG_CONFIG_FOUND" ]; then
                if command -v pg_config >/dev/null 2>&1; then
                    export PG_CONFIG="$(command -v pg_config)"
                    PG_CONFIG_FOUND="true"
                    log "Found pg_config via which: $PG_CONFIG"
                fi
            fi
            
            # If still not found, error out
            if [ -z "$PG_CONFIG_FOUND" ]; then
                err "pg_config not found. PostgreSQL development packages may not be installed."
                err "Please ensure PostgreSQL is installed via pg-setup action first"
                exit 1
            fi
            
            # Set additional PostgreSQL environment variables
            PG_CONFIG_DIR="$(dirname "$PG_CONFIG")"
            PG_ROOT="$(dirname "$PG_CONFIG_DIR")"
            
            export PKG_CONFIG_PATH="${PG_ROOT}/lib/pkgconfig:${PKG_CONFIG_PATH:-}"
            export LDFLAGS="-L${PG_ROOT}/lib ${LDFLAGS:-}"
            export CPPFLAGS="-I${PG_ROOT}/include ${CPPFLAGS:-}"
            
            # Debug: Show PostgreSQL environment
            log "PostgreSQL environment:"
            log "  PG_CONFIG: ${PG_CONFIG}"
            log "  PG_ROOT: ${PG_ROOT}"
            log "  PATH: ${PATH}"
            log "  PKG_CONFIG_PATH: ${PKG_CONFIG_PATH}"
            
            # Choose build method based on detected tool
            case "$build_tool" in
                "mingw32-make")
                    if [ -f "Makefile.win" ]; then
                        log "Using mingw32-make with Makefile.win (preferred for Windows builds)"
                        # Export PGXS environment variable for mingw32-make
                        if [ -n "$PGXS" ]; then
                            log "Using PGXS: $PGXS"
                            export PGXS
                        else
                            log "Warning: PGXS not set, mingw32-make may not find pgxs.mk"
                        fi
                        # Export environment variables for the make process
                        export PG_CONFIG
                        export PKG_CONFIG_PATH
                        export LDFLAGS
                        export CPPFLAGS
                        
                        if [ -n "$extra" ]; then
                            cmd_arr=( "$build_tool_path" -f Makefile.win $extra $target )
                        else
                            cmd_arr=( "$build_tool_path" -f Makefile.win $target )
                        fi
                    else
                        log "Makefile.win not found, using mingw32-make with regular Makefile"
                        # Export environment variables for the make process
                        export PG_CONFIG
                        export PKG_CONFIG_PATH
                        export LDFLAGS
                        export CPPFLAGS
                        
                        if [ -n "$extra" ]; then
                            cmd_arr=( "$build_tool_path" $extra $target )
                        else
                            cmd_arr=( "$build_tool_path" $target )
                        fi
                    fi
                    ;;
                "nmake")
                    if [ -f "Makefile.win" ]; then
                        log "Using nmake with Makefile.win"
                        # Export PGXS environment variable for nmake
                        if [ -n "$PGXS" ]; then
                            log "Using PGXS: $PGXS"
                            export PGXS
                        else
                            log "Warning: PGXS not set, nmake may not find pgxs.mk"
                        fi
                        if [ -n "$extra" ]; then
                            cmd_arr=( nmake /NOLOGO /F Makefile.win $extra $target )
                        else
                            cmd_arr=( nmake /NOLOGO /F Makefile.win $target )
                        fi
                    else
                        log "Makefile.win not found, falling back to regular make with nmake"
                        if [ -n "$extra" ]; then
                            cmd_arr=( "$build_tool_path" $extra $target )
                        else
                            cmd_arr=( "$build_tool_path" $target )
                        fi
                    fi
                    ;;
                "make")
                    log "Using make with environment variables"
                    log "Warning: Your build may require mingw32-make or nmake for proper Windows compilation"
                    
                    # Export environment variables for the make process
                    export PG_CONFIG
                    export PKG_CONFIG_PATH
                    export LDFLAGS
                    export CPPFLAGS
                    
                    if [ -n "$extra" ]; then
                        cmd_arr=( "$build_tool_path" $extra $target )
                    else
                        cmd_arr=( "$build_tool_path" $target )
                    fi
                    ;;
                *)
                    err "Unknown build tool: $build_tool"
                    exit 1
                    ;;
            esac
            ;;
         macos)
             # Set up PostgreSQL development environment
             export PATH="/opt/homebrew/bin:/usr/local/bin:${PATH}"
             
             # Find and set PG_CONFIG - try multiple common locations
             PG_CONFIG_FOUND=""
             
             # Check common Homebrew locations dynamically
             for base_dir in "/opt/homebrew" "/usr/local"; do
                 if [ -d "$base_dir" ]; then
                     log "Searching for PostgreSQL in: $base_dir"
                     # Check bin directory first
                     if [ -x "$base_dir/bin/pg_config" ]; then
                         export PG_CONFIG="$base_dir/bin/pg_config"
                         PG_CONFIG_FOUND="true"
                         log "Found pg_config at: $base_dir/bin/pg_config"
                         break
                     fi
                     # Then check version-specific directories
                     if [ -d "$base_dir/opt" ]; then
                         for version_dir in $(ls -1 "$base_dir/opt" 2>/dev/null | grep -E '^postgresql@[0-9]+(\.[0-9]+)?$' | sort -V -r); do
                             pg_path="$base_dir/opt/$version_dir/bin/pg_config"
                             if [ -x "$pg_path" ]; then
                                 export PG_CONFIG="$pg_path"
                                 PG_CONFIG_FOUND="true"
                                 log "Found pg_config at: $pg_path (version: $version_dir)"
                                 break 2
                             fi
                         done
                     fi
                 fi
             done
             
             # If not found in common locations, try which command
             if [ -z "$PG_CONFIG_FOUND" ]; then
                 if command -v pg_config >/dev/null 2>&1; then
                     export PG_CONFIG="$(command -v pg_config)"
                     PG_CONFIG_FOUND="true"
                     log "Found pg_config via which: $PG_CONFIG"
                 fi
             fi
             
             # If still not found, error out
             if [ -z "$PG_CONFIG_FOUND" ]; then
                 err "pg_config not found. PostgreSQL development packages may not be installed."
                 err "Please ensure PostgreSQL is installed via Homebrew: brew install postgresql@<version>"
                 err "Searched locations: /opt/homebrew/bin, /usr/local/bin, and common PostgreSQL version paths"
                 exit 1
             fi
             
             # Set additional PostgreSQL environment variables based on PG_CONFIG location
             PG_CONFIG_DIR="$(dirname "$PG_CONFIG")"
             PG_ROOT="$(dirname "$PG_CONFIG_DIR")"
             
             export PKG_CONFIG_PATH="${PG_ROOT}/lib/pkgconfig:${PKG_CONFIG_PATH:-}"
             export LDFLAGS="-L${PG_ROOT}/lib ${LDFLAGS:-}"
             export CPPFLAGS="-I${PG_ROOT}/include ${CPPFLAGS:-}"
             
             # Find other PostgreSQL utilities
             PG_PSQL="$(find_pg_utility "psql" "$PG_CONFIG")"
             PG_ISREADY="$(find_pg_utility "pg_isready" "$PG_CONFIG")"
             PG_CREATEDB="$(find_pg_utility "createdb" "$PG_CONFIG")"
             
             # Export utility paths for use in make commands and test scripts
             if [ -n "$PG_PSQL" ]; then
                 export PG_PSQL="$PG_PSQL"
             fi
             if [ -n "$PG_ISREADY" ]; then
                 export PG_ISREADY="$PG_ISREADY"
                 # Also add to PATH so test scripts can find it
                 export PATH="$(dirname "$PG_ISREADY"):$PATH"
             fi
             if [ -n "$PG_CREATEDB" ]; then
                 export PG_CREATEDB="$PG_CREATEDB"
             fi
             
             # Debug: Show PostgreSQL environment
             log "PostgreSQL environment:"
             log "  PG_CONFIG: ${PG_CONFIG}"
             log "  PG_ROOT: ${PG_ROOT}"
             log "  PG_PSQL: ${PG_PSQL:-not found}"
             log "  PG_ISREADY: ${PG_ISREADY:-not found}"
             log "  PG_CREATEDB: ${PG_CREATEDB:-not found}"
             log "  PATH: ${PATH}"
             log "  PKG_CONFIG_PATH: ${PKG_CONFIG_PATH}"

            if [ "$target" = "install" ]; then
                if [ -n "$extra" ]; then
                    cmd_arr=( sudo -E env PATH="$PATH" PG_CONFIG="$PG_CONFIG" PKG_CONFIG_PATH="$PKG_CONFIG_PATH" LDFLAGS="$LDFLAGS" CPPFLAGS="$CPPFLAGS" PG_PSQL="${PG_PSQL:-}" PG_ISREADY="${PG_ISREADY:-}" PG_CREATEDB="${PG_CREATEDB:-}" make $extra $target )
                else
                    cmd_arr=( sudo -E env PATH="$PATH" PG_CONFIG="$PG_CONFIG" PKG_CONFIG_PATH="$PKG_CONFIG_PATH" LDFLAGS="$LDFLAGS" CPPFLAGS="$CPPFLAGS" PG_PSQL="${PG_PSQL:-}" PG_ISREADY="${PG_ISREADY:-}" PG_CREATEDB="${PG_CREATEDB:-}" make $target )
                fi
            else
                if [ -n "$extra" ]; then
                    cmd_arr=( make $extra $target )
                else
                    cmd_arr=( make $target )
                fi
            fi
            ;;
         *)
             # linux / other unix
             # Ensure pg_config is available
             if ! command -v pg_config >/dev/null 2>&1; then
                 err "pg_config not found. PostgreSQL development packages may not be installed."
                 err "Please install PostgreSQL development packages for your system."
                 exit 1
             fi
             
             if [ "$target" = "install" ]; then
                 if [ -n "$extra" ]; then
                     cmd_arr=( sudo make $extra $target )
                 else
                     cmd_arr=( sudo make $target )
                 fi
             else
                 if [ -n "$extra" ]; then
                     cmd_arr=( make $extra $target )
                 else
                     cmd_arr=( make $target )
                 fi
             fi
             ;;
    esac

    # execute
    if run_cmd "${cmd_arr[@]}"; then
        return 0
    else
        return $?
    fi
}

main() {
    local os_input="${1:-}"     # optional operating system (linux, macos, windows)
    local make_tool_input="${2:-}"  # optional make tool for Windows (mingw32-make, nmake, make)
    local extra="${3:-}"        # optional extra make vars (e.g. "PGUSER=postgres")
    local rc=0

    # Parse OS and version from input
    parse_os() {
        local input="$1"
        
        # Check for specific OS versions
        case "$input" in
            ubuntu-*|debian-*|centos-*|rhel-*|fedora-*|suse-*|alpine-*)
                echo "linux"
                ;;
            macos-*|darwin-*)
                echo "macos"
                ;;
            windows-*|win-*)
                echo "windows"
                ;;
            linux|macos|windows)
                echo "$input"
                ;;
            *)
                # Auto-detect if invalid input provided
                detect_os
                ;;
        esac
    }

    OS=$(parse_os "$os_input")
    OS_VERSION="$os_input"

    if [[ "$os_input" == "linux" || "$os_input" == "macos" || "$os_input" == "windows" ]]; then
        log "Using specified operating system: $OS"
    else
        log "Using specified operating system: $OS (version: $OS_VERSION)"
    fi
    log "Starting build (make)..."
    if ! run_make "" "$extra" "$make_tool_input"; then
        err "Build step failed"
        show_regression_diffs
        exit 1
    fi

    log "Installing extension (make install)..."
    if ! run_make "install" "$extra" "$make_tool_input"; then
        err "Install step failed"
        show_regression_diffs
        exit 2
    fi

    # Check if PostgreSQL is ready before running tests
    if [ "$OS" = "macos" ]; then
        check_pg_ready
        
        # Ensure postgres role exists for testing
        log "Ensuring postgres role exists..."
        if [ -n "$PG_PSQL" ] && [ -x "$PG_PSQL" ]; then
            "$PG_PSQL" -d postgres -c "CREATE ROLE postgres WITH LOGIN SUPERUSER CREATEDB CREATEROLE;" 2>/dev/null || log "postgres role already exists or creation failed"
        elif command -v psql >/dev/null 2>&1; then
            psql -d postgres -c "CREATE ROLE postgres WITH LOGIN SUPERUSER CREATEDB CREATEROLE;" 2>/dev/null || log "postgres role already exists or creation failed"
        fi
    fi
    
    log "Running tests (make installcheck)..."
    # If extra is empty, default to PGUSER=postgres for installcheck
    local ic_extra="${extra:-PGUSER=postgres}"
    if ! run_make "installcheck" "$ic_extra" "$make_tool_input"; then
        err "installcheck failed"
        show_regression_diffs
        exit 3
    fi

    ok "All steps completed successfully (build / install / installcheck)"
    exit 0
}

# Entry: optional single argument string passed to make as extra vars
main "${1:-}"
