#!/usr/bin/env bash

set -e

HOST="${HOST:-github.com}"

if [[ -n ${AUTH_TOKEN} ]]; then
    prefix="${AUTH_TOKEN}:x-oauth-basic@"
fi

# Get operating system from first argument or auto-detect
OS_INPUT="${1:-linux}"

# Parse OS and version from input
parse_os() {
    local input="$1"
    
    # Check for specific OS versions
    case "$input" in
        ubuntu-*|debian-*|centos-*|rhel-*|fedora-*|suse-*|alpine-*)
            echo "linux"
            ;;
        macos-*|darwin-*)
            echo "macos"
            ;;
        windows-*|win-*)
            echo "windows"
            ;;
        linux|macos|windows)
            echo "$input"
            ;;
        *)
            # Auto-detect if invalid input provided
            case "$(uname -s)" in
                Linux*)     echo "linux";;
                Darwin*)    echo "macos";;
                CYGWIN*|MINGW*|MSYS*) echo "windows";;
                *)          echo "unknown";;
            esac
            ;;
    esac
}

OS=$(parse_os "$OS_INPUT")
OS_VERSION="$OS_INPUT"

if [[ "$OS_INPUT" == "linux" || "$OS_INPUT" == "macos" || "$OS_INPUT" == "windows" ]]; then
    echo "Using specified operating system: $OS"
else
    echo "Using specified operating system: $OS (version: $OS_VERSION)"
fi

# Shift to get remaining arguments (repositories)
shift 2>/dev/null || true

# Function to run make with appropriate permissions
run_make() {
    local directory=$1
    local target=$2
    local args=$3
    
    case $OS in
        "windows")
            # On Windows, use mingw32-make or make directly
            if command -v mingw32-make &> /dev/null; then
                mingw32-make -C ${directory} $args $target
            else
                make -C ${directory} $args $target
            fi
            ;;
        "macos")
            # On macOS, ensure we have the right environment for make
            export PATH="/opt/homebrew/bin:/usr/local/bin:$PATH"
            
            # Find and set PG_CONFIG - try multiple common locations
            PG_CONFIG_FOUND=""
            
            # Check common Homebrew locations
            for pg_path in "/opt/homebrew/bin/pg_config" "/usr/local/bin/pg_config" "/opt/homebrew/opt/postgresql@14/bin/pg_config" "/opt/homebrew/opt/postgresql@15/bin/pg_config" "/opt/homebrew/opt/postgresql@16/bin/pg_config" "/opt/homebrew/opt/postgresql@17/bin/pg_config"; do
                if [ -x "$pg_path" ]; then
                    export PG_CONFIG="$pg_path"
                    PG_CONFIG_FOUND="true"
                    echo "Found pg_config at: $pg_path"
                    break
                fi
            done
            
            # If not found in common locations, try which command
            if [ -z "$PG_CONFIG_FOUND" ]; then
                if command -v pg_config >/dev/null 2>&1; then
                    export PG_CONFIG="$(command -v pg_config)"
                    PG_CONFIG_FOUND="true"
                    echo "Found pg_config via which: $PG_CONFIG"
                fi
            fi
            
            # If still not found, error out
            if [ -z "$PG_CONFIG_FOUND" ]; then
                echo "Error: pg_config not found. PostgreSQL development packages may not be installed."
                echo "Searched locations: /opt/homebrew/bin, /usr/local/bin, and common PostgreSQL version paths"
                exit 1
            fi
            
            # Set additional PostgreSQL environment variables based on PG_CONFIG location
            PG_CONFIG_DIR="$(dirname "$PG_CONFIG")"
            PG_ROOT="$(dirname "$PG_CONFIG_DIR")"
            
            export PKG_CONFIG_PATH="${PG_ROOT}/lib/pkgconfig:$PKG_CONFIG_PATH"
            export LDFLAGS="-L${PG_ROOT}/lib $LDFLAGS"
            export CPPFLAGS="-I${PG_ROOT}/include $CPPFLAGS"
            
            if [[ $target == "install" ]]; then
                sudo -E env PG_CONFIG="$PG_CONFIG" PKG_CONFIG_PATH="$PKG_CONFIG_PATH" LDFLAGS="$LDFLAGS" CPPFLAGS="$CPPFLAGS" make -C ${directory} $args $target
            else
                make -C ${directory} $args $target
            fi
            ;;
        *)
            # On Linux and other Unix-like systems, use make with sudo for install
            if [[ $target == "install" ]]; then
                sudo make -C ${directory} $args $target
            else
                make -C ${directory} $args $target
            fi
            ;;
    esac
}

for repo in $@
do
    echo "Cloning and building https://${HOST}/${repo}.git..."

    # clone repo
    directory=$(echo ${repo} | tr / _)
    git clone https://${prefix}${HOST}/${repo}.git ${directory}

    # build and install extension
    run_make ${directory} "" "CFLAGS=\"${CFLAGS}\""
    run_make ${directory} "install"
done
