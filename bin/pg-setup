#!/usr/bin/env bash
set -euo pipefail
[ -n "${DEBUG:-}" ] && set -x

if [[ $# -lt 1 ]]; then
  cat <<EOF
Usage:
  pg_setup.sh PG_VERSION [OPERATING_SYSTEM] [CONTRIB]

Arguments:
  PG_VERSION        PostgreSQL major version (e.g. 14)
  OPERATING_SYSTEM  Optional: linux | macos | windows | ubuntu-22.04 | windows-2022 etc.
  CONTRIB           Optional: 'true' to install contrib packages (default: false)
EOF
  exit 1
fi

PG_VERSION=$1
OS_INPUT=${2:-linux}
CONTRIB=${3:-false}

# normalize OS input
parse_os() {
  local in="$1"
  case "$in" in
    ubuntu-*|debian-*|centos-*|rhel-*|fedora-*|suse-*|alpine-*) echo "linux" ;;
    macos-*|darwin-*) echo "macos" ;;
    windows-*|win-*) echo "windows" ;;
    linux|macos|windows) echo "$in" ;;
    *) case "$(uname -s 2>/dev/null || true)" in
         Linux*) echo "linux" ;;
         Darwin*) echo "macos" ;;
         CYGWIN*|MINGW*|MSYS*) echo "windows" ;;
         *) echo "linux" ;; # default to linux
       esac ;;
  esac
}

OS="$(parse_os "$OS_INPUT")"
OS_VERSION="$OS_INPUT"
echo "Target OS: $OS (input: $OS_VERSION)"
echo "Requested PG version: $PG_VERSION"
echo "Install contrib: ${CONTRIB}"

# Helper to write env to GITHUB_ENV if present (for Actions), else export locally
write_env() {
  local key=$1
  local val=$2
  if [[ -n "${GITHUB_ENV:-}" ]]; then
    printf '%s=%s\n' "$key" "$val" >> "$GITHUB_ENV"
  else
    export "$key"="$val"
  fi
}

#
# Linux (apt) - preserve your original flow and dev package install
#
install_postgresql_linux() {
  local version=$1
  local contrib=$2

  echo "Installing PostgreSQL $version on Linux (apt-based)..."

  # Best-effort clean old Postgres packages
  dpkg-query -f '${Package}\n' -W | grep ^postgresql | xargs -r sudo dpkg --purge || true

  # Add PGDG repo and install packages
  curl -fsSL https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add - || true
  sudo sh -c "echo 'deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main' > /etc/apt/sources.list.d/pgdg.list"
  sudo apt-get update -y
  # Install server, dev and client
  DEBIAN_FRONTEND=noninteractive sudo apt-get install -y \
    postgresql-"$version" \
    postgresql-server-dev-"$version" \
    postgresql-client-"$version" || true

  if [[ "$contrib" == "true" ]]; then
    DEBIAN_FRONTEND=noninteractive sudo apt-get install -y postgresql-contrib-"$version" || true
  fi

  # Relax auth for CI convenience — same as before
  if [[ -f /etc/postgresql/"$version"/main/pg_hba.conf ]]; then
    sudo tee /etc/postgresql/"$version"/main/pg_hba.conf >/dev/null <<EOF
local all all trust
host all all 0/0 trust
host all all ::0/0 trust
EOF
    sudo service postgresql reload || true
  fi

  # Export pg_config info if available
  if command -v pg_config &>/dev/null; then
    PGC="$(command -v pg_config)"
    write_env "PG_CONFIG" "$PGC"
    # export additional directories
    write_env "PG_INCLUDEDIR" "$($PGC --includedir 2>/dev/null || true)"
    write_env "PG_LIBDIR" "$($PGC --libdir 2>/dev/null || true)"
    write_env "PG_PKGLIBDIR" "$($PGC --pkglibdir 2>/dev/null || true)"
    write_env "PG_BINDIR" "$($PGC --bindir 2>/dev/null || true)"
    write_env "PG_SHAREDIR" "$($PGC --sharedir 2>/dev/null || true)"
  fi

  echo "Linux install complete."
}

#
# macOS (Homebrew) - preserve behavior
#
install_postgresql_macos() {
  local version=$1
  local contrib=$2

  echo "Installing PostgreSQL $version on macOS (Homebrew)..."
  if ! command -v brew &>/dev/null; then
    echo "Homebrew missing — installing..."
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
  fi

  brew install "postgresql@$version" || true

  # Ensure PATH for this process & persist to interactive shells (non-fatal)
  export PATH="/opt/homebrew/opt/postgresql@$version/bin:$PATH"
  echo "export PATH=\"/opt/homebrew/opt/postgresql@$version/bin:\$PATH\"" >> ~/.zshrc || true
  echo "export PATH=\"/opt/homebrew/opt/postgresql@$version/bin:\$PATH\"" >> ~/.bash_profile || true

  # Export PG_CONFIG and other envs
  PGC="/opt/homebrew/opt/postgresql@$version/bin/pg_config"
  if [[ -x "$PGC" ]]; then
    write_env "PG_CONFIG" "$PGC"
    write_env "PG_INCLUDEDIR" "$($PGC --includedir 2>/dev/null || true)"
    write_env "PG_LIBDIR" "$($PGC --libdir 2>/dev/null || true)"
    write_env "PG_PKGLIBDIR" "$($PGC --pkglibdir 2>/dev/null || true)"
    write_env "PG_BINDIR" "$($PGC --bindir 2>/dev/null || true)"
    write_env "PG_SHAREDIR" "$($PGC --sharedir 2>/dev/null || true)"
  fi

  brew services start "postgresql@$version" || true
  sleep 2

  # Ensure postgres role/db exist (best-effort)
  /opt/homebrew/opt/postgresql@"$version"/bin/psql -d postgres -c '\du' >/dev/null 2>&1 || true
  /opt/homebrew/opt/postgresql@"$version"/bin/psql -d postgres -c "CREATE ROLE postgres WITH LOGIN SUPERUSER CREATEDB CREATEROLE;" 2>/dev/null || true
  /opt/homebrew/opt/postgresql@"$version"/bin/createdb postgres || true

  echo "macOS install complete."
}

#
# Windows installer: restore and preserve original choco attempts, prefer Program Files pg_config,
# export PGXS/PG_* vars to GITHUB_ENV, do not create fake pgxs.mk
#
install_postgresql_windows() {
  local version=$1
  local contrib=$2
  local pf_root="/c/Program Files/PostgreSQL/$version"
  local pf_bin="$pf_root/bin"

  echo "Installing PostgreSQL $version on Windows..."

  # Install Chocolatey if missing
  if ! command -v choco &>/dev/null; then
    echo "Installing Chocolatey..."
    powershell -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \
      "Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))"
  fi

  # Try multiple package names like your previous original script did
  echo "Attempting per-version Chocolatey package installs (mirrors prior behavior)..."
  if choco install "postgresql$version" -y; then
    echo "Installed postgresql$version via choco"
  else
    echo "postgresql$version not available; trying alternate package names..."
    if choco install "postgresql" --version "$version" -y; then
      echo "Installed postgresql version via choco"
    elif choco install "postgresql$version-dev" -y; then
      echo "Installed postgresql$version-dev via choco"
    else
      echo "Falling back to generic postgresql package via choco"
      choco install postgresql -y || true
    fi
  fi

  # Add Program Files bin to PATH for this session if present
  if [[ -d "$pf_bin" ]]; then
    export PATH="$pf_bin:$PATH"
  fi

  # Wait briefly for installer to settle
  sleep 4

  # Try to initdb if data dir missing
  if [[ -x "$pf_bin/initdb.exe" && ! -d "$pf_root/data" ]]; then
    echo "Running initdb (best-effort)..."
    "$pf_bin/initdb.exe" -D "$pf_root/data" || true
  fi

  # Start service attempts (best-effort)
  net start "postgresql-x64-$version" >/dev/null 2>&1 || true
  net start "postgresql-$version" >/dev/null 2>&1 || true
  net start postgresql >/dev/null 2>&1 || true
  sleep 2

  # Try creating the postgres DB if createdb available
  if [[ -x "$pf_bin/createdb.exe" ]]; then
    "$pf_bin/createdb.exe" postgres || true
  fi

  #
  # Robust PGXS detection and exports:
  # Prefer Program Files pg_config.exe if present, then fall back to pg_config on PATH
  #
  PF_PG_CONFIG="$pf_bin/pg_config.exe"
  PG_CONFIG_CMD=""

  if [[ -x "$PF_PG_CONFIG" ]]; then
    echo "Using pg_config from Program Files: $PF_PG_CONFIG"
    PG_CONFIG_CMD="$PF_PG_CONFIG"
  elif command -v pg_config >/dev/null 2>&1; then
    PATH_PG_CONFIG="$(command -v pg_config)"
    echo "pg_config found on PATH: $PATH_PG_CONFIG"
    PG_CONFIG_CMD="$PATH_PG_CONFIG"
  else
    # nothing present — error because build will almost certainly fail without dev tools
    echo "Error: pg_config not found on PATH nor in Program Files. PostgreSQL dev tools may be missing."
    echo "Please ensure the Windows runner has Postgres dev files installed."
    exit 1
  fi

  # Query pg_config for pgxs location
  PGXS_CAND="$("$PG_CONFIG_CMD" --pgxs 2>/dev/null || true)"
  echo "pg_config --pgxs => ${PGXS_CAND:-<empty>}"

  # If pgxs exists on filesystem, export it. Otherwise, export canonical PG_* directories as fallback.
  if [[ -n "$PGXS_CAND" && -f "$PGXS_CAND" ]]; then
    echo "pgxs.mk found at: $PGXS_CAND"
    write_env "PGXS" "$PGXS_CAND"
    write_env "PG_CONFIG" "$PG_CONFIG_CMD"
    # also export canonical dirs for convenience
    write_env "PG_BINDIR" "$("$PG_CONFIG_CMD" --bindir 2>/dev/null || true)"
    write_env "PG_INCLUDEDIR" "$("$PG_CONFIG_CMD" --includedir 2>/dev/null || true)"
    write_env "PG_LIBDIR" "$("$PG_CONFIG_CMD" --libdir 2>/dev/null || true)"
    write_env "PG_PKGLIBDIR" "$("$PG_CONFIG_CMD" --pkglibdir 2>/dev/null || true)"
    write_env "PG_SHAREDIR" "$("$PG_CONFIG_CMD" --sharedir 2>/dev/null || true)"
    write_env "PGXS_AVAILABLE" "true"
    echo "Exported PGXS and PG_* variables for CI."
  else
    echo "pgxs.mk not present at pg_config --pgxs ('$PGXS_CAND'). Falling back to PG_* exports."
    # read canonical values and export them
    PG_BINDIR="$("$PG_CONFIG_CMD" --bindir 2>/dev/null || true)"
    PG_INCLUDEDIR="$("$PG_CONFIG_CMD" --includedir 2>/dev/null || true)"
    PG_LIBDIR="$("$PG_CONFIG_CMD" --libdir 2>/dev/null || true)"
    PG_PKGLIBDIR="$("$PG_CONFIG_CMD" --pkglibdir 2>/dev/null || true)"
    PG_SHAREDIR="$("$PG_CONFIG_CMD" --sharedir 2>/dev/null || true)"

    echo "Detected (via pg_config):"
    echo "  PG_BINDIR    = ${PG_BINDIR:-<empty>}"
    echo "  PG_INCLUDEDIR= ${PG_INCLUDEDIR:-<empty>}"
    echo "  PG_LIBDIR    = ${PG_LIBDIR:-<empty>}"
    echo "  PG_PKGLIBDIR = ${PG_PKGLIBDIR:-<empty>}"
    echo "  PG_SHAREDIR  = ${PG_SHAREDIR:-<empty>}"

    write_env "PG_CONFIG" "$PG_CONFIG_CMD"
    write_env "PG_BINDIR" "$PG_BINDIR"
    write_env "PG_INCLUDEDIR" "$PG_INCLUDEDIR"
    write_env "PG_LIBDIR" "$PG_LIBDIR"
    write_env "PG_PKGLIBDIR" "$PG_PKGLIBDIR"
    write_env "PG_SHAREDIR" "$PG_SHAREDIR"
    write_env "PGXS_AVAILABLE" "false"

    # as an extra: attempt to locate pgxs under Program Files if present (but do NOT create fake pgxs.mk)
    POSSIBLE_PGXS="$pf_root/lib/postgresql/pgxs/src/makefiles/pgxs.mk"
    if [[ -f "$POSSIBLE_PGXS" ]]; then
      echo "Found pgxs.mk at expected Program Files layout: $POSSIBLE_PGXS"
      write_env "PGXS" "$POSSIBLE_PGXS"
      write_env "PGXS_AVAILABLE" "true"
    else
      echo "pgxs.mk not found under Program Files common location ($POSSIBLE_PGXS). Will rely on PG_* fallback values."
    fi
  fi

  echo "Windows install/detection complete."
}

# Dispatch to correct installer
case "$OS" in
  linux)
    install_postgresql_linux "$PG_VERSION" "$CONTRIB"
    ;;
  macos)
    install_postgresql_macos "$PG_VERSION" "$CONTRIB"
    ;;
  windows)
    install_postgresql_windows "$PG_VERSION" "$CONTRIB"
    ;;
  *)
    echo "Unsupported OS: $OS"
    exit 1
    ;;
esac

echo "pg_setup.sh complete (PG version: $PG_VERSION, OS: $OS)."
